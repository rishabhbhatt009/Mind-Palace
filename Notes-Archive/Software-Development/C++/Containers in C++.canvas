{
	"nodes":[
		{"id":"c869bb007c665109","x":-780,"y":-920,"width":620,"height":240,"type":"text","text":"# Containers in C++ : \n\n- sequence containers (`array`, `vector`, `list`, `deque`), \n- associative containers (`set`, `map`), \n- unordered associative containers (`unordered_set`, `unordered_map`), and \n- container adaptors (`stack`, `queue`, `priority_queue`)\n- others : `pair`"},
		{"id":"098cff42ecc3674d","x":-780,"y":-640,"width":640,"height":700,"type":"text","text":"STD-Array\n\n```cpp\n#include <array>\n\n// Declaration \nstd::array<int, 10> arr; // garbage values on initialization\n\n// Traversal \nfor (int i=0, i<arr.size(), i++) {arr[i]=1}\nfor (auto itr = arr.begin(); itr != arr.end(); i++) {*itr = 1;}\n// where `auto` = `std::array<int, 10>::iterator`\nfor (auto i : arr) {i=1} // i is copy, doesn't modifies original array \nfor (auto& i : arr) {i=1} // i is reference, modifies original array \n\n// Operations : \n// - size(), data(), begin(), end()\n```\n\n---\n\n- Implicit Default Initialization of Remaining Elements : `int v[26] = {0, };`\n- C-Arrays : \n\t- About : Are contiguous. **Compile time allocation** -> array created in **stack** -> garbage collection when it goes out of scope. **Run time allocation** -> array created in **heap** -> manually delete. \n\t- Limitation : Does not provide `index out of range`\n\n---"},
		{"id":"3ff35a43046cfc82","x":-780,"y":80,"width":440,"height":220,"type":"text","text":"\nSTD Deque : \n- double ended queue \n- similar to vector but more efficient insertion and deletion \n- directive : `#include <deque>`\n- declaration : `std::deque<int> lst`"},
		{"id":"4d8286131bc5beec","x":-780,"y":320,"width":440,"height":240,"type":"text","text":"STD List : \n- doubly linked list \n- directive : `#include <list>`\n- declaration : `std::list<int> lst`\n- insertion, deletion is easy, however you have to go through all elements/node to get size/access elements\n"},
		{"id":"6080dc39bf3aa01f","x":-780,"y":580,"width":440,"height":220,"type":"text","text":"STD Set : \n- `std::set` : implemented as balanced binary search trees (like Red-Black Trees)\n- `std::unordered_set` : implemented as hashmap \n- Operations : \n\t- "},
		{"id":"f533777d96ffd2d4","x":-120,"y":-640,"width":640,"height":700,"type":"text","text":"STD-Vector : \n\n```cpp\n#include <vector>\n\n// Declaration\nstd::vector<int> a; // empty vector \nstd::vector<int> a(10); // vector with size (initialize to 0)\nstd::vector<int> a(10,1); // vector with size and initialize to value\nstd::vector<int> a = {0,1,2,3,4,5,6,7,8,9};\nstd::vector<int> copy = vec; // copy\n\n// Traversal \nfor (size_t i = 0; i < vec.size(); ++i) {vec[i];} // using index  \n// range-based for loop \nfor (auto val : vec) {cout<<val;} // copy of the val\nfor (auto& x : vec) {x=20;} // points to the actual vec cell\nfor (auto it = vec.begin(); it != vec.end(); ++it) {*it;} \n// points to the actual vec cell\n\n// Opearations\n// - size(), push_back(), pop_back()\n```\n\n---\n- When we add elements to a vector and there isn't enough space all elements are copied to a new location with enough space. Therefore old pointers might not be valid anymore\n\n---\n"},
		{"id":"3b3995447dcdef5c","x":540,"y":-640,"width":600,"height":700,"type":"text","text":"STD Map : \n\n```cpp\n#include <map>\n#include <unordered_map>\n\n// Declaration \nstd::map<char,int> hashmap;\n\n// Traversal \nfor (auto& pair : m2) // range-based for loop \n// std::pair<const int, int>\n// Access pair.first (key) and pair.second (value)\nfor (auto it = m2.begin(); it != m2.end(); ++it) // using itr \n// Access it->first (key) and it->second (value)\nfor (auto& [key, value] : map) {}\n\n// Operations \n// - hasmap[] = val // insert (if key does not exist) or update \n// - size(), empty(), find()\n```\n\n---\n\n- `std::map` : implemented as a balanced binary search tree (like a Red-Black tree), \n- `std::unordered_map` : implemented as hashmap (more efficient)\n\n---"}
	],
	"edges":[]
}